
ATTRIBUTE_GRAMMAR
  MODULE AG ;
  ATTRIBUTION_MODEL Attributed {
    attributed_module_name = AT
  } ;

  AXIOM prog ;

ATTRIBUTE value_ : int ;
CHAIN rpn : string list ;

ATTRIBUTES
  bin_oper : int -> int -> int ;
  env : (string * int) list ;
  result : int ;
  rhs_must_be_nonzero : bool ;
  un_oper int -> int ;
  rpn_notation : string list ;
  operator_text : string ;
  freevars : string list ;
END ;

RULE INT : expr := int
COMPUTE
  $0.value_ := $1 ;
  $0.rpn := (string_of_int $1) :: $0.rpn ;
END ;

RULE BINOP : expr := binop and expr and expr
COMPUTE
  $0.value_ := $result ;
  $result := $1.bin_oper $2.value_ $3.value_ ;
  $0.rpn := $1.operator_text :: $3.rpn ;
  condition "rhs must be nonzero"
    (if $1.rhs_must_be_nonzero then
       0 <> $3.value_
     else true) ;
END ;

RULE UNOP : expr := unop and expr
COMPUTE
  $0.value_ := $1.un_oper $2.value_ ;
  $0.rpn := $1.operator_text :: $2.rpn ;
END ;

RULE REF : expr := ref_expr
COMPUTE
  $0.value_ := $1.value_ ;
END ;

RULE SEQ : expr := expr and expr
COMPUTE
  $0.value_ := $2.value_ ;
  $0.rpn := ";" :: $2.rpn ;
END ;

RULE LET : expr := let_expr
COMPUTE
  $0.value_ := $1.value_ ;
  $0.rpn := $1.rpn ;
END ;

RULE LET_BINDING : let_expr := string and expr and expr
COMPUTE
  $0.value_ := $3.value_ ;
  $3.rpn := (Printf.sprintf "bind %s" $1) :: $2.rpn ;
  $0.env := ($1, $2.value_) :: INCLUDING ( block1.env, let_expr.env ) ;
  $0.freevars :=
    Std.union
      (CONCAT (ref_expr.freevars, let_expr.freevars) IN $2)
      (Std.except $1 (CONCAT (ref_expr.freevars, let_expr.freevars) IN $3)) ;
END ;

RULE REF_EXPR : ref_expr := string
COMPUTE
  $0.value_ := List.assoc $1 (INCLUDING (block1.env, let_expr.env)) ;
  $0.rpn := $1 :: $0.rpn ;
  $0.freevars := [$1] ;
END ;

RULE UPLUS : unop
COMPUTE
  $0.un_oper := (fun x -> x) ;
  $0.operator_text := "unary+" ;
END ;

RULE UMINUS : unop
COMPUTE
  $0.un_oper := (fun x -> (- x)) ;
  $0.operator_text := "unary-" ;
END ;


RULE PLUS : binop
COMPUTE
  $0.bin_oper := (+) ;
  $0.rhs_must_be_nonzero := false ;
  $0.operator_text := "+" ;
END ;

RULE MINUS : binop
COMPUTE
  $0.bin_oper := (-) ;
  $0.rhs_must_be_nonzero := false ;
  $0.operator_text := "-" ;
END ;

RULE STAR : binop
COMPUTE
  $0.bin_oper := (fun a b -> a*b) ;
  $0.rhs_must_be_nonzero := false ;
  $0.operator_text := "*" ;
END ;

RULE SLASH : binop
COMPUTE
  $0.bin_oper := (fun a b -> if b = 0 then 0 else a / b) ;
  $0.rhs_must_be_nonzero := true ;
  $0.operator_text := "/" ;
END ;

RULE PERCENT : binop
COMPUTE
  $0.bin_oper := (mod) ;
  $0.rhs_must_be_nonzero := true ;
  $0.operator_text := "%" ;
END ;

RULE BLOCK1 : block1 := block2
COMPUTE
  $0.value_ := $1.value_ ;
END ;


RULE BLOCK2 : block2 := expr
COMPUTE
  $0.value_ := $1.value_ ;
END ;


RULE PROG : prog := block1
COMPUTE
  $1.env := [("x", 1); ("y", 2); ("z", 3); ("w", 4)] ;
  $0.value_ := $1.value_ ;
  CHAINSTART $1.rpn := [] ;
  $0.rpn_notation := List.rev $1.rpn ;
  $0.freevars := CONCAT (ref_expr.freevars, let_expr.freevars) IN $1 ;
END ;
END ;
